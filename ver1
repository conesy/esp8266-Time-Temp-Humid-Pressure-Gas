/*! @file I2CDemo.ino

  @section I2CDemo_intro_section Description

  Example program for using I2C to set and read the Bosch BME680 sensor. The sensor measures
  temperature, pressure and humidity and is described at
  https://www.bosch-sensortec.com/bst/products/all_products/BME680. The datasheet is available from
  Bosch at https://ae-bst.resource.bosch.com/media/_tech/media/datasheets/BST-BME680_DS001-11.pdf \n\n

  The most recent version of the BME680 library is available at https://github.com/SV-Zanshin/BME680
  and the documentation of the library as well as example programs are described in the project's wiki
  pages located at https://github.com/SV-Zanshin/BME680/wiki. \n\n

  The BME680 is an extremely small physical package that is so tiny as to be impossible to solder at
  home, hence it will be used as part of a third-party breakout board. There are several such boards
  available at this time, for example \n Company  | Link
  -------  | ----------
  Sparkfun | https://www.sparkfun.com/products/14570
  BlueDot  | https://www.bluedot.space/sensor-boards/bme680/
  Adafruit |
  https://learn.adafruit.com/adafruit-BME680-humidity-barometric-pressure-temperature-sensor-breakout
  \n\n

  Bosch supplies sample software that runs on various platforms, including the Arduino family; this
  can be downloaed at https://github.com/BoschSensortec/BSEC-Arduino-library . This software is part
  of the Bosch "BSEC" (Bosch Sensortec Environmental Cluster) framework and somewhat bulky and
  unwieldy for typical Arduino applications, hence the choice to make a more compact and rather less
  abstract library.

  This example program initializes the BME680 to use I2C for communications. The library does not
  using floating point numbers to save on memory space and computation time. The values for
  Temperature, Pressure and Humidity are returned in deci-units, e.g. a Temperature reading of "2731"
  means "27.31" degrees Celsius. The display in the example program uses floating point for
  demonstration purposes only.  Note that the temperature reading is generally higher than the ambient
  temperature due to die and PCB temperature and self-heating of the element.\n\n

  The pressure reading needs to be adjusted for altitude to get the adjusted pressure reading. There
  are numerous sources on the internet for formulae converting from standard sea-level pressure to
  altitude, see the data sheet for the BME180 on page 16 of
  http://www.adafruit.com/datasheets/BST-BMP180-DS000-09.pdf. Rather than put a floating-point
  function in the library which may not be used but which would use space, an example altitude
  computation function has been added to this example program to show how it might be done.

  @section I2CDemolicense License

  This program is free software: you can redistribute it and/or modify it under the terms of the GNU
  General Public License as published by the Free Software Foundation, either version 3 of the
  License, or (at your option) any later version. This program is distributed in the hope that it will
  be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
  FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have
  received a copy of the GNU General Public License along with this program.  If not, see
  <http://www.gnu.org/licenses/>.

  @section I2CDemoauthor Author

  Written by Arnd\@SV-Zanshin

  @section I2CDemoversions Changelog

  Version | Date       | Developer  | Comments
  ------- | ---------- | ---------- | ---------------------------------------------------------------
  1.0.3   | 2020-07-04 | SV-Zanshin | Issue #25 implement clang-formatting
  1.0.2   | 2020-05-09 | SV-Zanshin | Issue #8  clean up comments and code
  1.0.1   | 2019-01-30 | SV-Zanshin |           Removed old comments
  1.0.1   | 2019-01-26 | SV-Zanshin | Issue #3  convert documentation to Doxygen
  1.0.0b  | 2018-06-30 | SV-Zanshin |           Cloned from original BME280 program
*/
#include "Zanshin_BME680.h"  // Include the BME680 Sensor library
/**************************************************************************************************
** Declare all program constants                                                                 **
**************************************************************************************************/
const uint32_t SERIAL_SPEED {
  115200
};  ///< Set the baud rate for Serial I/O

/**************************************************************************************************
** Declare global variables and instantiate classes                                              **
**************************************************************************************************/
BME680_Class BME680;  ///< Create an instance of the BME680 class
///< Forward function declaration with default value for sea level
float altitude(const int32_t press, const float seaLevel = 1013.25);
float altitude(const int32_t press, const float seaLevel) {
  /*!
    @brief     This converts a pressure measurement into a height in meters
    @details   The corrected sea-level pressure can be passed into the function if it is known,
             otherwise the standard atmospheric pressure of 1013.25hPa is used (see
             https://en.wikipedia.org/wiki/Atmospheric_pressure) for details.
    @param[in] press    Pressure reading from BME680
    @param[in] seaLevel Sea-Level pressure in millibars
    @return    floating point altitude in meters.
  */
  static float Altitude;
  Altitude =
    44330.0 * (1.0 - pow(((float)press / 100.0) / seaLevel, 0.1903));  // Convert into meters
  return (Altitude);
}  // of method altitude()





#include <TimeLib.h>
#include <ESP8266WiFi.h>
#include <WiFiUdp.h>

const char ssid[] = "xxx";  //  your network SSID (name)
const char pass[] = "xxx";       // your network password

// NTP Servers:
static const char ntpServerName[] = "us.pool.ntp.org";
//static const char ntpServerName[] = "time.nist.gov";
//static const char ntpServerName[] = "time-a.timefreq.bldrdoc.gov";
//static const char ntpServerName[] = "time-b.timefreq.bldrdoc.gov";
//static const char ntpServerName[] = "time-c.timefreq.bldrdoc.gov";

const int timeZone = 1;     // Central European Time
//const int timeZone = -5;  // Eastern Standard Time (USA)
//const int timeZone = -4;  // Eastern Daylight Time (USA)
//const int timeZone = -8;  // Pacific Standard Time (USA)
//const int timeZone = -7;  // Pacific Daylight Time (USA)


WiFiUDP Udp;
unsigned int localPort = 8888;  // local port to listen for UDP packets

time_t getNtpTime();
void digitalClockDisplay();
void printDigits(int digits);
void sendNTPpacket(IPAddress &address);


/*******************************modular tft_eSPI definitions ----START-----***************************/
#define WAIT 0// Pause in milliseconds to set scroll speed
#include <TFT_eSPI.h>                 // Include the graphics library (this includes the sprite functions)
TFT_eSPI    tft = TFT_eSPI();         // Create object "tft"
/*******************************modular tft_eSPI definitions----END-----***************************/
#include <ESP8266WiFi.h>
/******************************************************************/
// -------------------------------------------------------------------------
// Setup
// -------------------------------------------------------------------------
void setup() {
  Serial.begin(SERIAL_SPEED);  // Start serial port at Baud rate

  /*******************************void setup() SCREEN TEST TFT_eSPI----START-----***************************/
  tft.init();
  tft.setRotation(0);
  tft.fillScreen(toInt(0, 0, 0));//paint screen once with black.
  Serial.println("Initialisation --------------------- OK");
  /*******************************void setup() SCREEN TEST TFT_eSPI----END-----***************************/

  /*!
    @brief    Arduino method called once at startup to initialize the system
    @details  This is an Arduino IDE method which is called first upon boot or restart. It is only
            called one time and then control goes to the main "loop()" method, from which
            control never returns
    @return   void
  */



#ifdef __AVR_ATmega32U4__      // If this is a 32U4 processor, then wait 3 seconds to init USB port
  delay(3000);
#endif
  Serial.print(F("Starting I2CDemo example program for BME680\n"));
  Serial.print(F("- Initializing BME680 sensor\n"));
  while (!BME680.begin(I2C_STANDARD_MODE)) {  // Start BME680 using I2C, use first device found
    Serial.print(F("-  Unable to find BME680. Trying again in 5 seconds.\n"));
    delay(5000);
  }  // of loop until device is located
  Serial.print(F("- Setting 16x oversampling for all sensors\n"));
  BME680.setOversampling(TemperatureSensor, Oversample16);  // Use enumerated type values
  BME680.setOversampling(HumiditySensor, Oversample16);     // Use enumerated type values
  BME680.setOversampling(PressureSensor, Oversample16);     // Use enumerated type values
  Serial.print(F("- Setting IIR filter to a value of 4 samples\n"));
  BME680.setIIRFilter(IIR4);  // Use enumerated type values
  Serial.print(F("- Setting gas measurement to 320\xC2\xB0\x43 for 150ms\n"));  // "�C" symbols
  BME680.setGas(320, 150);  // 320�c for 150 milliseconds


  delay(250);
  Serial.println("TimeNTP Example");
  Serial.print("Connecting to ");
  Serial.println(ssid);
  WiFi.begin(s, pass);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.print("IP number assigned by DHCP is ");
  Serial.println(WiFi.localIP());
  Serial.println("Starting UDP");
  Udp.begin(localPort);
  Serial.print("Local port: ");
  Serial.println(Udp.localPort());
  Serial.println("waiting for sync");
  setSyncProvider(getNtpTime);
  setSyncInterval(300);

}  // of method setup()


time_t prevDisplay = 0; // when the digital clock was displayed

static int32_t  temp, humidity, pressure, gas;  // BME readings

void loop() {
  runBME680();
  delay(50);
  delay(3000);
  digitalClockDisplay();
  delay(1000);
  BME680.getSensorData(temp, humidity, pressure, gas);  // Get readings
  delay(1000);
  Serial.println("temp is");
  Serial.println(temp);


  /*******************************void loop() SCREEN TEST TFT_eSPI----START-----***************************/
  Serial.println("Attempting to print two sample display segments.");
  int displayheight1 = 100;
  static char     buf2[16];                        // sprintf text buffer
  sprintf(buf2, "%4d %3d.%02d", (7 - 1) % 9999,  // Clamp to 9999,
          (int8_t)(temp / 100), (uint8_t)(temp % 100));   // Temp in decidegrees
  sprintf(buf2, "%3d.%02d",   // Clamp to 9999,
          (int8_t)(temp / 100), (uint8_t)(temp % 100));   // Temp in decidegrees
  Serial.print(buf2);
  String temp3 = buf2;
  // String temp1 = temp / 100;
  // String temp2 = String( temp % 100);
  // String temp1n2 = temp1 + "." temp2;
  Serial.println(temp3);
  DisplaySegmentTandH (2, displayheight1,  "Temperature", temp3);
  DisplaySegmentTandH (2, displayheight1 + 80,  "humidity ",  String((uint8_t)(humidity % 100)));
  DisplaySegment      (2, displayheight1 + 160,  "Pressure", pressure); //don't send numbers with decimals. Use atoi(String(number_input))) to remove decimals with no rounding.
  //   delay(4000);


  //            (int8_t)(temp / 100), (uint8_t)(temp % 100));   // Temp in decidegrees
  //    sprintf(buf, "%3d.%03d", (int8_t)(humidity / 1000),
  //            (uint16_t)(humidity % 1000));  // Humidity milli-pct
  //    sprintf(buf, "%7d.%02d", (int16_t)(pressure / 100),
  //            (uint8_t)(pressure % 100));  // Pressure Pascals
  //    alt = altitude(pressure);                                                // temp altitude
  //    sprintf(buf, "%5d.%02d", (int16_t)(alt), ((uint8_t)(alt * 100) % 100));  // Altitude meters
  //    sprintf(buf, "%4d.%02d\n", (int16_t)(gas / 100), (uint8_t)(gas % 100));  // Resistance milliohms
  /*******************************void loop() SCREEN TEST TFT_eSPI----END-----***************************/


}

void runBME680()
{
  /*!
    @brief    Arduino method for the main program loop
    @details  This is the main program for the Arduino IDE, it is an infinite loop and keeps on
            repeating. The "sprintf()" function is to pretty-print the values, since floating
            point is not supported on the Arduino, split the values into those before and those
            after the decimal point.
    @return   void
  */
  //  static int32_t  temp, humidity, pressure, gas;  // BME readings
  static char     buf[16];                        // sprintf text buffer
  static float    alt;                            // Temporary variable
  static uint16_t loopCounter = 0;                // Display iterations
  if (loopCounter % 25 == 0) {                    // Show header @25 loops
    Serial.print(F("\nLoop Temp\xC2\xB0\x43 Humid% Press hPa   Alt m Air m"));
    Serial.print(F("\xE2\x84\xA6\n==== ====== ====== ========= ======= ======\n"));  // "�C" symbol
  }                                                     // if-then time to show headers
  BME680.getSensorData(temp, humidity, pressure, gas);  // Get readings
  if (loopCounter++ != 0) {                             // Ignore first reading, might be incorrect
    sprintf(buf, "%4d %3d.%02d", (loopCounter - 1) % 9999,  // Clamp to 9999,
            (int8_t)(temp / 100), (uint8_t)(temp % 100));   // Temp in decidegrees
    Serial.print(buf);
    sprintf(buf, "%3d.%03d", (int8_t)(humidity / 1000),
            (uint16_t)(humidity % 1000));  // Humidity milli-pct
    Serial.print(buf);
    sprintf(buf, "%7d.%02d", (int16_t)(pressure / 100),
            (uint8_t)(pressure % 100));  // Pressure Pascals
    Serial.print(buf);
    alt = altitude(pressure);                                                // temp altitude
    sprintf(buf, "%5d.%02d", (int16_t)(alt), ((uint8_t)(alt * 100) % 100));  // Altitude meters
    Serial.print(buf);
    sprintf(buf, "%4d.%02d\n", (int16_t)(gas / 100), (uint8_t)(gas % 100));  // Resistance milliohms
    Serial.print(buf);
    delay(10000);  // Wait 10s
  }                // of ignore first reading
}  // of method loop()

void digitalClockDisplay()
{
  // digital clock display of the time
  Serial.print(hour());
  printDigits(minute());
  printDigits(second());
  Serial.print(" ");
  Serial.print(day());
  Serial.print(".");
  Serial.print(month());
  Serial.print(".");
  Serial.print(year());
  Serial.println();
}

void printDigits(int digits)
{
  // utility for digital clock display: prints preceding colon and leading 0
  Serial.print(":");
  if (digits < 10)
    Serial.print('0');
  Serial.print(digits);
}

/*-------- NTP code ----------*/

const int NTP_PACKET_SIZE = 48; // NTP time is in the first 48 bytes of message
byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming & outgoing packets

time_t getNtpTime()
{
  IPAddress ntpServerIP; // NTP server's ip address

  while (Udp.parsePacket() > 0) ; // discard any previously received packets
  Serial.println("Transmit NTP Request");
  // get a random server from the pool
  WiFi.hostByName(ntpServerName, ntpServerIP);
  Serial.print(ntpServerName);
  Serial.print(": ");
  Serial.println(ntpServerIP);
  sendNTPpacket(ntpServerIP);
  uint32_t beginWait = millis();
  while (millis() - beginWait < 1500) {
    int size = Udp.parsePacket();
    if (size >= NTP_PACKET_SIZE) {
      Serial.println("Receive NTP Response");
      Udp.read(packetBuffer, NTP_PACKET_SIZE);  // read packet into the buffer
      unsigned long secsSince1900;
      // convert four bytes starting at location 40 to a long integer
      secsSince1900 =  (unsigned long)packetBuffer[40] << 24;
      secsSince1900 |= (unsigned long)packetBuffer[41] << 16;
      secsSince1900 |= (unsigned long)packetBuffer[42] << 8;
      secsSince1900 |= (unsigned long)packetBuffer[43];
      return secsSince1900 - 2208988800UL + timeZone * SECS_PER_HOUR;
    }
  }
  Serial.println("No NTP Response :-(");
  return 0; // return 0 if unable to get the time
}

// send an NTP request to the time server at the given address
void sendNTPpacket(IPAddress &address)
{
  // set all bytes in the buffer to 0
  memset(packetBuffer, 0, NTP_PACKET_SIZE);
  // Initialize values needed to form NTP request
  // (see URL above for details on the packets)
  packetBuffer[0] = 0b11100011;   // LI, Version, Mode
  packetBuffer[1] = 0;     // Stratum, or type of clock
  packetBuffer[2] = 6;     // Polling Interval
  packetBuffer[3] = 0xEC;  // Peer Clock Precision
  // 8 bytes of zero for Root Delay & Root Dispersion
  packetBuffer[12] = 49;
  packetBuffer[13] = 0x4E;
  packetBuffer[14] = 49;
  packetBuffer[15] = 52;
  // all NTP fields have been given values, now
  // you can send a packet requesting a timestamp:
  Udp.beginPacket(address, 123); //NTP requests are to port 123
  Udp.write(packetBuffer, NTP_PACKET_SIZE);
  Udp.endPacket();
}


/*******************************extra functions TFT_eSPI----START-----***************************/
int32_t toInt(int32_t r, int32_t g, int32_t b) {
  return (((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3));
}

void DisplaySegment (int32_t xDS, int32_t yDS, String Room, int int_to_display) //by HMCNS-display a pretty rectangle at coords xDS and yDS
{
  int32_t wDS = 200;  //width
  int32_t hDS = 75; //height = width
  int32_t rDS = 7;  //radius of rectangle corner
  int32_t boDS = 1  ;      // border offset
  tft.fillRoundRect(xDS, yDS, wDS, hDS, rDS, toInt(12, 25, 12));   // usage : tft.fillRoundRect(x,y,w,h,r,color);0,40,0 = dark green background//TFT_VIOLET //TFT_DARKGREY**********set background squre color
  tft.drawRoundRect(xDS - boDS, yDS - boDS, wDS + (2 * boDS), hDS + (2 * boDS), rDS, toInt(random(0, 255), random(0, 255), random(0, 255))); //TFT_CYAN is yellow...  DARKGREEN is blueish
  tft.drawRoundRect(xDS - boDS - boDS, yDS - boDS - boDS, wDS + (4 * boDS), hDS + (4 * boDS), rDS + 1, toInt(random(0, 255), random(0, 255), random(0, 255))); //TFT_CYAN is yellow...  DARKGREEN is blueish
  tft.setTextColor(toInt(0, 255, 0)); //toInt(0, 255, 15) = bright greenish.//toInt(40, 255, 40) bright faded green//(255, 0, 255)=pink
  tft.setTextFont(1); //font for segment heading
  tft.setTextSize(1);
  tft.drawString(Room, xDS + 3 , yDS + 3 );
  Serial.println("int_to_display");
  Serial.println(int_to_display);
  tft.setTextFont(1);           // Font 4 selected setTextFont(2)+setTextSize(8 fills almost perfectly) //// 4 and 4 works real niceI see
  tft.setTextSize(3);
  tft.drawString(String(int_to_display), xDS + 1 , yDS + 14 );
  delay(90);
}
void DisplaySegmentTandH (int32_t xDS, int32_t yDS, String Room, String int_to_display_as_string) //by HMCNS-display a pretty rectangle at coords xDS and yDS
{
  int32_t wDS = 200;  //width
  int32_t hDS = 75; //height = width
  int32_t rDS = 7;  //radius of rectangle corner
  int32_t boDS = 1  ;      // border offset
  tft.fillRoundRect(xDS, yDS, wDS, hDS, rDS, toInt(12, 25, 12));   // usage : tft.fillRoundRect(x,y,w,h,r,color);0,40,0 = dark green background//TFT_VIOLET //TFT_DARKGREY**********set background squre color
  tft.drawRoundRect(xDS - boDS, yDS - boDS, wDS + (2 * boDS), hDS + (2 * boDS), rDS, toInt(random(0, 255), random(0, 255), random(0, 255))); //TFT_CYAN is yellow...  DARKGREEN is blueish
  tft.drawRoundRect(xDS - boDS - boDS, yDS - boDS - boDS, wDS + (4 * boDS), hDS + (4 * boDS), rDS + 1, toInt(random(0, 255), random(0, 255), random(0, 255))); //TFT_CYAN is yellow...  DARKGREEN is blueish
  tft.setTextColor(toInt(0, 255, 0)); //toInt(0, 255, 15) = bright greenish.//toInt(40, 255, 40) bright faded green//(255, 0, 255)=pink
  tft.setTextFont(1); //font for segment heading
  tft.setTextSize(1);
  tft.drawString(Room, xDS + 3 , yDS + 3 );
  Serial.println("int_to_display");
  Serial.println(int_to_display_as_string);
  tft.setTextFont(3);           // Font 4 selected setTextFont(2)+setTextSize(8 fills almost perfectly) //// 4 and 4 works real niceI see
  tft.setTextSize(3);
  tft.drawString(int_to_display_as_string, xDS + 1 , yDS + 14 );
  delay(90);
}
/*******************************extra functions TFT_eSPI----END-----***************************/
